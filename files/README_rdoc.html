<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>README.rdoc</title>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<link href='../css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  function popupCode(url) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }
  
  function toggleCode(id) {
    var code = document.getElementById(id)
  
    code.style.display = code.style.display != 'block' ? 'block' : 'none'
    return true
  }
  
  // Make codeblocks hidden by default
  document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
</script>
</head>
<body class='page'>
<div class='file' id='wrapper'>
<div class='header'>
<h1 class='name'>README.rdoc
</h1>
<div class='paths'>
README.rdoc
</div>
<div class='last-update'>
Last Update:
<span class='datetime'>2022-12-31 12:44:40 -0800</span>
</div>
</div>
<div id='content'>
<div id='text'>
<div id='description'>
<h1 id="label-Forme"><a href="../classes/Forme.html"><code>Forme</code></a><span><a href="#label-Forme">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p><a href="../classes/Forme.html"><code>Forme</code></a> is a HTML forms library for ruby with the following goals:</p>
<ol><li>
<p>Have no external dependencies</p>
</li><li>
<p>Have a simple API</p>
</li><li>
<p>Support forms both with and without related objects</p>
</li><li>
<p>Allow compiling down to different types of output</p>
</li><li>
<p>Integrate easily into web frameworks</p>
</li></ol>

<h1 id="label-Introduction">Introduction<span><a href="#label-Introduction">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p><a href="../classes/Forme.html"><code>Forme</code></a> is designed to make creating HTML forms easier.  Flexibility and ease of use are the primary objectives.  Hereâ€™s a basic example, showing usage without a related object:</p>

<pre class="ruby"><span class="ruby-constant">Forme</span>.<span class="ruby-identifier">form</span>({<span class="ruby-value">:action</span><span class="ruby-operator">=&gt;</span><span class="ruby-string">&#39;/foo&#39;</span>}) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span>(<span class="ruby-value">:text</span>, <span class="ruby-value">:name</span><span class="ruby-operator">=&gt;</span><span class="ruby-string">&#39;bar&#39;</span>)
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">tag</span>(<span class="ruby-value">:fieldset</span>) <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span>(<span class="ruby-value">:textarea</span>, <span class="ruby-value">:name</span><span class="ruby-operator">=&gt;</span><span class="ruby-string">&#39;baz&#39;</span>)
  <span class="ruby-keyword">end</span>
 <span class="ruby-identifier">f</span>.<span class="ruby-identifier">button</span>(<span class="ruby-string">&#39;Update&#39;</span>)
<span class="ruby-keyword">end</span>
</pre>

<p>This results in the following HTML:</p>

<pre>&lt;form action=&quot;/foo&quot;&gt;
  &lt;input name=&quot;bar&quot; type=&quot;text&quot;/&gt;
  &lt;fieldset&gt;
    &lt;textarea name=&quot;baz&quot;&gt;&lt;/textarea&gt;
  &lt;/fieldset&gt;
  &lt;input type=&quot;submit&quot; value=&quot;Update&quot;/&gt;
&lt;/form&gt;</pre>

<p><a href="../classes/Forme.html"><code>Forme</code></a> also supports forms that are associated with objects, and has specific support for Sequel::Model objects to allow easily building forms for such objects.  The <a href="../classes/Sequel.html"><code>Sequel</code></a> support handles inputs based on database columns, and automatically handles labels and errors:</p>

<pre class="ruby"><span class="ruby-constant">Forme</span>.<span class="ruby-identifier">form</span>(<span class="ruby-constant">Album</span>[<span class="ruby-value">1</span>], <span class="ruby-value">action:</span> <span class="ruby-string">&#39;/foo&#39;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:name</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:copies_sold</span>
<span class="ruby-keyword">end</span>
</pre>

<p>This results in the following HTML:</p>

<pre>&lt;form action=&quot;/foo&quot; method=&quot;post&quot;&gt;
  &lt;label&gt;Name:
    &lt;input id=&quot;album_name&quot; name=&quot;album[name]&quot; type=&quot;text&quot; value=&quot;Rising Force&quot;/&gt;
  &lt;/label&gt;
  &lt;label&gt;Copies Sold:
    &lt;input id=&quot;album_copies_sold&quot; inputmode=&quot;numeric&quot; name=&quot;album[copies_sold]&quot; pattern=&quot;-?[0-9]*&quot; type=&quot;text&quot; value=&quot;100000&quot;/&gt;
  &lt;/label&gt;
&lt;/form&gt;</pre>

<p>In addition to integrating with <a href="../classes/Sequel.html"><code>Sequel</code></a>, <a href="../classes/Forme.html"><code>Forme</code></a> also integrates into three separate web frameworks, <a href="../classes/Roda.html"><code>Roda</code></a>, Rails, and Sinatra, allowing use of forms inside templates.  This is the most common usage of <a href="../classes/Forme.html"><code>Forme</code></a>.</p>

<p>One distinct advantage of <a href="../classes/Forme.html"><code>Forme</code></a> over other form libraries is the use of an abstract syntax tree internally, allowing the same form code to compile to different HTML with different options.  For example, it allows using the exactly same form code to display a form you can modify as well as a read-only view, just by passing a single option when creating the form.  For example, with the first example in this section, if you pass the <code>formatter: :readonly</code> option, you get the following HTML instead:</p>

<pre>&lt;form action=&quot;/foo&quot;&gt;
  &lt;span class=&quot;readonly-text&quot;&gt;&lt;/span&gt;
  &lt;fieldset&gt;
    &lt;div class=&quot;readonly-textarea&quot;&gt;&lt;/div&gt;
  &lt;/fieldset&gt;
&lt;/form&gt;</pre>

<p>This allows you to reuse the same form code in multiple contexts, which can save considerable development time.</p>

<h1 id="label-Installation">Installation<span><a href="#label-Installation">&para;</a> <a href="#top">&uarr;</a></span></h1>

<pre class="ruby"><span class="ruby-identifier">gem</span> <span class="ruby-identifier">install</span> <span class="ruby-identifier">forme</span>
</pre>

<h1 id="label-Links">Links<span><a href="#label-Links">&para;</a> <a href="#top">&uarr;</a></span></h1>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>Demo Site </td><td>
<p><a target="_top" href="http://forme-demo.jeremyevans.net">forme-demo.jeremyevans.net</a></p>
</td></tr><tr><td class='label'>RDoc </td><td>
<p><a target="_top" href="http://forme.jeremyevans.net">forme.jeremyevans.net</a></p>
</td></tr><tr><td class='label'>Source </td><td>
<p><a target="_top" href="https://github.com/jeremyevans/forme">github.com/jeremyevans/forme</a></p>
</td></tr><tr><td class='label'>Discussion Forum </td><td>
<p><a target="_top" href="https://github.com/jeremyevans/forme/discussions">github.com/jeremyevans/forme/discussions</a></p>
</td></tr><tr><td class='label'>Bug Tracker </td><td>
<p><a target="_top" href="https://github.com/jeremyevans/forme/issues">github.com/jeremyevans/forme/issues</a></p>
</td></tr></tbody></table>

<h1 id="label-Direct+Instantiation">Direct Instantiation<span><a href="#label-Direct+Instantiation">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>While not typically done, you can instantiate <a href="../classes/Forme/Form.html"><code>Forme::Form</code></a> objects directly and use them:</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">Forme</span><span class="ruby-operator">::</span><span class="ruby-constant">Form</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">open</span>(<span class="ruby-value">:action</span><span class="ruby-operator">=&gt;</span><span class="ruby-string">&#39;/foo&#39;</span>, <span class="ruby-value">:method</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">:post</span>) <span class="ruby-comment"># &#39;&lt;form action=&quot;/foo&quot; method=&quot;post&quot;&gt;&#39;</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span>(<span class="ruby-value">:textarea</span>, <span class="ruby-value">:value</span><span class="ruby-operator">=&gt;</span><span class="ruby-string">&#39;foo&#39;</span>, <span class="ruby-value">:name</span><span class="ruby-operator">=&gt;</span><span class="ruby-string">&#39;bar&#39;</span>) <span class="ruby-comment"># &#39;&lt;textarea name=&quot;bar&quot;&gt;foo&lt;/textarea&gt;&#39;</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span>(<span class="ruby-value">:text</span>, <span class="ruby-value">:value</span><span class="ruby-operator">=&gt;</span><span class="ruby-string">&#39;foo&#39;</span>, <span class="ruby-value">:name</span><span class="ruby-operator">=&gt;</span><span class="ruby-string">&#39;bar&#39;</span>) <span class="ruby-comment"># &#39;&lt;input name=&quot;bar&quot; type=&quot;text&quot; value=&quot;foo&quot;/&gt;&#39;</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">close</span> <span class="ruby-comment"># &#39;&lt;/form&gt;&#39;</span>
</pre>

<p>With an object, <code>Form#input</code> calls <code>forme_input</code> on the obj with the form, field, and options, which should return a <code>Forme::Input</code> or <code>Forme::Tag</code> instance.  Also, in <code>Form#initialize</code>, <code>forme_config</code> is called on object with the form if the object responds to it, allowing customization of the entire form based on the object.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">Forme</span><span class="ruby-operator">::</span><span class="ruby-constant">Form</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">obj</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span>(<span class="ruby-value">:field</span>) <span class="ruby-comment"># &#39;&lt;input id=&quot;obj_field&quot; name=&quot;obj[field]&quot; type=&quot;text&quot; value=&quot;foo&quot;/&gt;&#39;</span>
</pre>

<p>If the object doesnâ€™t respond to <code>forme_input</code>, it falls back to creating text fields with the name and id set to the field name and the value set by calling the given method on the object (or using [] if the object is a hash).</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">Forme</span><span class="ruby-operator">::</span><span class="ruby-constant">Form</span>.<span class="ruby-identifier">new</span>([<span class="ruby-value">:foo</span>])
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span>(<span class="ruby-value">:first</span>) <span class="ruby-comment"># &#39;&lt;input id=&quot;first&quot; name=&quot;first&quot; type=&quot;text&quot; value=&quot;foo&quot;/&gt;&#39;</span>
</pre>

<h1 id="label-Forme-3A-3AForm+Creation"><a href="../classes/Forme/Form.html"><code>Forme::Form</code></a> Creation<span><a href="#label-Forme-3A-3AForm+Creation">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p><code>Forme.form</code> takes up to 3 arguments, and yields the <a href="../classes/Forme/Form.html"><code>Forme::Form</code></a> object to the block (if given).  Here are the argument styles that you can use for <code>Forme.form</code>.</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>No args </td><td>
<p>Creates a <code>Form</code> object with no options and not associated to an <code>obj</code>, and with no attributes in the opening tag.</p>
</td></tr><tr><td class='label'>1 hash arg </td><td>
<p>Treated as opening form tag attributes, creating a <code>Form</code> object with no options.</p>
</td></tr><tr><td class='label'>1 non-hash arg </td><td>
<p>Treated as the <code>Form</code>â€˜s <code>obj</code>, with empty options and no attributes in the opening tag.</p>
</td></tr><tr><td class='label'>2 hash args </td><td>
<p>First hash is opening attributes, second hash is <code>Form</code> options.</p>
</td></tr><tr><td class='label'>1 non-hash arg, 1-2 hash args </td><td>
<p>First argument is <code>Form</code>â€˜s obj, second is opening attributes, third if provided is <code>Form</code>â€™s options.</p>
</td></tr></tbody></table>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-comment"># No arguments</span>
<span class="ruby-constant">Forme</span>.<span class="ruby-identifier">form</span> 

<span class="ruby-comment"># 1 hash argument (attributes)</span>
<span class="ruby-constant">Forme</span>.<span class="ruby-identifier">form</span>(<span class="ruby-value">action:</span> <span class="ruby-string">&#39;/foo&#39;</span>)

<span class="ruby-comment"># 1 non-hash argument (a reference object used when building the form)</span>
<span class="ruby-constant">Forme</span>.<span class="ruby-identifier">form</span>(<span class="ruby-constant">Album</span>[<span class="ruby-value">1</span>])

<span class="ruby-comment"># 2 hash arguments (attributes, and options)</span>
<span class="ruby-constant">Forme</span>.<span class="ruby-identifier">form</span>({<span class="ruby-value">action:</span> <span class="ruby-string">&#39;/foo&#39;</span>}, <span class="ruby-value">values:</span> <span class="ruby-identifier">params</span>)

<span class="ruby-comment"># 1 non-hash argument, 1-2 hash arguments (ref obj, attributes, options)</span>
<span class="ruby-constant">Forme</span>.<span class="ruby-identifier">form</span>(<span class="ruby-constant">Album</span>[<span class="ruby-value">1</span>], <span class="ruby-value">action:</span> <span class="ruby-string">&#39;/foo&#39;</span>)
<span class="ruby-constant">Forme</span>.<span class="ruby-identifier">form</span>(<span class="ruby-constant">Album</span>[<span class="ruby-value">1</span>], {<span class="ruby-value">action:</span> <span class="ruby-string">&#39;/foo&#39;</span>}, <span class="ruby-value">values:</span> <span class="ruby-identifier">params</span>)
</pre>

<p>If you want a <a href="../classes/Forme/Form.html"><code>Forme::Form</code></a> instance where the reference object is a Hash, then you need to pass the hash object using the :obj option:</p>

<pre class="ruby"><span class="ruby-constant">Forme</span>.<span class="ruby-identifier">form</span>({<span class="ruby-value">action:</span> <span class="ruby-string">&#39;/foo&#39;</span>}, <span class="ruby-value">obj:</span> {<span class="ruby-value">foo:</span> <span class="ruby-string">&#39;bar&#39;</span>})
</pre>

<p>You can also create <a href="../classes/Forme/Form.html"><code>Forme::Form</code></a> objects the normal ruby way using Forme::Form#new.  The difference between Forme::Form#new and <a href="../classes/Forme.html#method-c-form"><code>Forme.form</code></a> is that <a href="../classes/Forme.html#method-c-form"><code>Forme.form</code></a> includes the enclosing &lt;form&gt; tag, where Forme::Form#new does not.  Because of this, <a href="../classes/Forme/Form.html"><code>Forme::Form</code></a> does not accept a hash of &lt;form&gt; tag attributes, so it has the following API:</p>

<pre class="ruby"><span class="ruby-comment"># No arguments</span>
<span class="ruby-constant">Forme</span><span class="ruby-operator">::</span><span class="ruby-constant">Form</span>.<span class="ruby-identifier">new</span>

<span class="ruby-comment"># 1 hash argument</span>
<span class="ruby-constant">Forme</span><span class="ruby-operator">::</span><span class="ruby-constant">Form</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">values:</span> <span class="ruby-identifier">params</span>)

<span class="ruby-comment"># 1 non-hash argument</span>
<span class="ruby-constant">Forme</span><span class="ruby-operator">::</span><span class="ruby-constant">Form</span>.<span class="ruby-identifier">new</span>(<span class="ruby-constant">Album</span>[<span class="ruby-value">1</span>])

<span class="ruby-comment"># 1 non-hash argument, 1-2 hash arguments</span>
<span class="ruby-constant">Forme</span><span class="ruby-operator">::</span><span class="ruby-constant">Form</span>.<span class="ruby-identifier">new</span>(<span class="ruby-constant">Album</span>[<span class="ruby-value">1</span>], <span class="ruby-value">values:</span> <span class="ruby-identifier">params</span>)
</pre>

<h1 id="label-Forme-3A-3AForm+Methods"><a href="../classes/Forme/Form.html"><code>Forme::Form</code></a> Methods<span><a href="#label-Forme-3A-3AForm+Methods">&para;</a> <a href="#top">&uarr;</a></span></h1>

<h2 id="label-form">form<span><a href="#label-form">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>If you create a Form via Forme::Forme#new, you can use the form method to create a form tag:</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">Forme</span><span class="ruby-operator">::</span><span class="ruby-constant">Form</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">form</span>(<span class="ruby-value">action:</span> <span class="ruby-string">&#39;/foo&#39;</span>)
</pre>

<p>This is what <a href="../classes/Forme.html#method-c-form"><code>Forme.form</code></a> uses internally to create the +&lt;form&gt;+ tag</p>

<h2 id="label-input">input<span><a href="#label-input">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>This adds an input to the form.  If the form has an associated object, and that object responds to <code>forme_input</code>, calls forme_input with the argument and options:</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">Forme</span><span class="ruby-operator">::</span><span class="ruby-constant">Form</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">obj</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span>(<span class="ruby-value">:field</span>) <span class="ruby-comment"># &#39;&lt;input id=&quot;obj_field&quot; name=&quot;obj[field]&quot; type=&quot;text&quot; value=&quot;foo&quot;/&gt;&#39;</span>
</pre>

<p>If the form has an associated object, and that object does not respond to <code>forme_input</code>, calls the method on the object (or uses [] if the object is a hash), and uses the result as the value for a text input:</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">Forme</span><span class="ruby-operator">::</span><span class="ruby-constant">Form</span>.<span class="ruby-identifier">new</span>([<span class="ruby-value">:foo</span>])
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span>(<span class="ruby-value">:first</span>) <span class="ruby-comment"># &#39;&lt;input id=&quot;first&quot; name=&quot;first&quot; type=&quot;text&quot; value=&quot;foo&quot;/&gt;&#39;</span>
</pre>

<p>If the object does not respond to <code>forme_input</code>, you can change the type of the input via the <code>:type</code> option:</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">Forme</span><span class="ruby-operator">::</span><span class="ruby-constant">Form</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">obj</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span>(<span class="ruby-value">:field</span>, <span class="ruby-value">:type</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">:email</span>) <span class="ruby-comment"># &#39;&lt;input id=&quot;obj_field&quot; name=&quot;obj[field]&quot; type=&quot;email&quot; value=&quot;foo&quot;/&gt;&#39;</span>
</pre>

<p>If the form does not have an associated object, the first argument is used as the input type:</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">Forme</span><span class="ruby-operator">::</span><span class="ruby-constant">Form</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span>(<span class="ruby-value">:text</span>) <span class="ruby-comment"># &#39;&lt;input type=&quot;text&quot; /&gt;&#39;</span>
</pre>

<p>The second argument is an options hash.  See below for the supported input types and options.</p>

<h2 id="label-tag">tag<span><a href="#label-tag">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>This adds a tag to the form.  If a block is given, yields to the block, and tags and inputs inside the block are placed inside the tag. The first argument is the type of tag to create, and the second argument if given should be a hash of tag attributes. This allows you to nest inputs inside tags:</p>

<pre class="ruby"><span class="ruby-constant">Forme</span>.<span class="ruby-identifier">form</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">tag</span>(<span class="ruby-value">:span</span>, <span class="ruby-value">:class</span><span class="ruby-operator">=&gt;</span><span class="ruby-string">&quot;foo&quot;</span>) <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span>(<span class="ruby-value">:text</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Which results in a form similar to the following:</p>

<pre>&lt;form&gt;
  &lt;span class=&quot;foo&quot;&gt;
    &lt;input type=&quot;text&quot;/&gt;
  &lt;/span&gt;
&lt;/form&gt;</pre>

<h2 id="label-inputs">inputs<span><a href="#label-inputs">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>This wraps multiple inputs in a tag (it uses the <code>:inputs_wrapper</code> transformer discussed below, so it uses a <code>fieldset</code> by default). You can give the inputs to add as an enumerable argument:</p>

<pre class="ruby"><span class="ruby-identifier">f</span>.<span class="ruby-identifier">inputs</span>([<span class="ruby-value">:textarea</span>, [<span class="ruby-value">:text</span>, <span class="ruby-value">:value</span><span class="ruby-operator">=&gt;</span><span class="ruby-string">&#39;a&#39;</span>]])
<span class="ruby-comment"># &lt;fieldset&gt;</span>
<span class="ruby-comment">#   &lt;textarea&gt;&lt;/textarea&gt;</span>
<span class="ruby-comment">#   &lt;input type=&quot;text&quot; value=&quot;a&quot;/&gt;</span>
<span class="ruby-comment"># &lt;/fieldset&gt;</span>
</pre>

<p>You can also provide a block:</p>

<pre class="ruby"><span class="ruby-identifier">f</span>.<span class="ruby-identifier">inputs</span>([<span class="ruby-value">:textarea</span>]) <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span>(<span class="ruby-value">:text</span>, <span class="ruby-value">:value</span><span class="ruby-operator">=&gt;</span><span class="ruby-string">&#39;a&#39;</span>)
<span class="ruby-keyword">end</span>
</pre>

<p>Any options given are passed to the <code>inputs_wrapper</code> (so you can use options such as <code>:legend</code> to set a legend for the fieldset), and also to the <code>with_opts</code> method (so you can use options such as <code>:wrapper</code> to modify the default wrapper transformer for inputs inside the block). There is also one option specific to the inputs method:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:nested_inputs_wrapper </td><td>
<p>Sets the default inputs_wrapper to use for calls to inputs inside the block.  The reason for this option is that <code>:inputs_wrapper</code> option affects the current call to inputs, so if you want to use a different inputs_wrapper for nested calls, you need this option.</p>
</td></tr></tbody></table>

<h2 id="label-button">button<span><a href="#label-button">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>This adds a submit input to the form:</p>

<pre class="ruby"><span class="ruby-identifier">f</span>.<span class="ruby-identifier">button</span>
<span class="ruby-comment"># &lt;input type=&quot;submit&quot;/&gt;</span>
</pre>

<p>It can be called with a string to provide a value for the button:</p>

<pre class="ruby"><span class="ruby-identifier">f</span>.<span class="ruby-identifier">button</span>(<span class="ruby-string">&#39;Search&#39;</span>)
<span class="ruby-comment"># &lt;input type=&quot;submit&quot; value=&quot;Search&quot;/&gt;</span>
</pre>

<p>It can be called with a hash to provide options for the submit input:</p>

<pre class="ruby"><span class="ruby-identifier">f</span>.<span class="ruby-identifier">button</span>(<span class="ruby-value">value:</span> <span class="ruby-string">&#39;Search&#39;</span>, <span class="ruby-value">class:</span> <span class="ruby-string">&#39;btn&#39;</span>)
<span class="ruby-comment"># &lt;input class=&quot;btn&quot; type=&quot;submit&quot; value=&quot;Search&quot;/&gt;</span>
</pre>

<h2 id="label-with_opts">with_opts<span><a href="#label-with_opts">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>This requires a block, and modifies the <a href="../classes/Forme/Form.html"><code>Forme::Form</code></a>â€˜s options inside the block, restoring the options when the block returns:</p>

<pre class="ruby"><span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span>(<span class="ruby-value">:text</span>)
<span class="ruby-comment"># &lt;input type=&quot;text&quot;/&gt;</span>

<span class="ruby-identifier">f</span>.<span class="ruby-identifier">with_opts</span>(<span class="ruby-value">wrapper:</span> <span class="ruby-value">:li</span>) <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span>(<span class="ruby-value">:text</span>)
<span class="ruby-keyword">end</span>
<span class="ruby-comment"># &lt;li&gt;&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;</span>
</pre>

<p>This supports most options you can provide to <a href="../classes/Forme/Form.html"><code>Forme::Form</code></a>, but not all.</p>

<h2 id="label-with_obj">with_obj<span><a href="#label-with_obj">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>This uses <code>with_opts</code> to change the <a href="../classes/Forme/Form.html"><code>Forme::Form</code></a> object temporarily. It yields the object to the block, and also supports appending to the existing namespaces:</p>

<pre class="ruby"><span class="ruby-constant">Forme</span>.<span class="ruby-identifier">form</span>([<span class="ruby-value">:foo</span>], {<span class="ruby-value">action:</span> <span class="ruby-string">&#39;/path&#39;</span>}, <span class="ruby-value">namespace:</span> <span class="ruby-string">&#39;a&#39;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span>(<span class="ruby-value">:first</span>)
  <span class="ruby-comment"># &lt;input id=&quot;a_first&quot; name=&quot;a[first]&quot; type=&quot;text&quot; value=&quot;foo&quot;/&gt;</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">with_obj</span>([<span class="ruby-string">&#39;foobar&#39;</span>], <span class="ruby-string">&#39;b&#39;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span>(<span class="ruby-value">:first</span>, <span class="ruby-value">:size</span><span class="ruby-operator">=&gt;</span><span class="ruby-identifier">o</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">size</span>)
    <span class="ruby-comment"># &lt;input id=&quot;a_b_first&quot; name=&quot;a[b][first]&quot; size=&quot;6&quot; type=&quot;text&quot; value=&quot;foobar&quot;/&gt;</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<h2 id="label-each_obj">each_obj<span><a href="#label-each_obj">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>This allows you to provide an object-yielding enumerable. <code>each_object</code> will call <code>with_obj</code> with each object in the enumerable.  It yields each object as well as the index of the object in the enumerable, and includes the index in the namespace:</p>

<pre class="ruby"><span class="ruby-identifier">objectlist</span> = [[<span class="ruby-string">&#39;foobar&#39;</span>], [<span class="ruby-string">&#39;good&#39;</span>]]
<span class="ruby-constant">Forme</span>.<span class="ruby-identifier">form</span>([<span class="ruby-value">:foo</span>], <span class="ruby-value">:namespace</span><span class="ruby-operator">=&gt;</span><span class="ruby-string">&#39;a&#39;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">each_obj</span>(<span class="ruby-identifier">objectlist</span>, <span class="ruby-string">&#39;b&#39;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">o</span>, <span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span>(<span class="ruby-value">:first</span>, <span class="ruby-value">:size</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">10</span><span class="ruby-operator">+</span><span class="ruby-identifier">i</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-comment"># &lt;input id=&quot;a_b_0_first&quot; name=&quot;a[b][0][first]&quot; size=&quot;10&quot; type=&quot;text&quot; value=&quot;foobar&quot;/&gt;</span>
  <span class="ruby-comment"># &lt;input id=&quot;a_b_1_first&quot; name=&quot;a[b][1][first]&quot; size=&quot;11&quot; type=&quot;text&quot; value=&quot;good&quot;/&gt;</span>
<span class="ruby-keyword">end</span>
</pre>

<h1 id="label-Sequel+Support"><a href="../classes/Sequel.html"><code>Sequel</code></a> Support<span><a href="#label-Sequel+Support">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p><a href="../classes/Forme.html"><code>Forme</code></a> ships with a <a href="../classes/Sequel.html"><code>Sequel</code></a> plugin (use <code>Sequel::Model.plugin :forme</code> to enable), that makes Sequel::Model instances support the <code>forme_config</code> and <code>forme_input</code> methods and return customized inputs. An additional instance method, <code>forme_namespace</code> can optionally be defined to customize how model classnames are transformed into form classes and input IDs and names. This can be useful if your Sequel::Model classes are nested under a parent namespace. The default namespace uses Sequel::Model#underscore.</p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">Admin</span>
  <span class="ruby-keyword">class</span> <span class="ruby-constant">Albums</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>
    <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forme_namespace</span>
      <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">underscore</span>.<span class="ruby-identifier">tr</span>(<span class="ruby-string">&#39;/&#39;</span>, <span class="ruby-string">&#39;_&#39;</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>The <a href="../classes/Sequel.html"><code>Sequel</code></a> :forme plugin also integerates with Sequelâ€™s validation reflection support that comes with the <a href="../classes/Sequel.html"><code>Sequel</code></a> validation_class_methods plugin.  It will add <code>pattern</code> and <code>maxlength</code> attributes based on the format, numericality, and length validations.</p>

<h2 id="label-Specialized+input+options+for+specific+column+types">Specialized input options for specific column types<span><a href="#label-Specialized+input+options+for+specific+column+types">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>In addition to the default <a href="../classes/Forme.html"><code>Forme</code></a> options, the <a href="../classes/Sequel.html"><code>Sequel</code></a> support includes, for specific column types,  these additional options to the input method:</p>

<h3 id="label-boolean">boolean<span><a href="#label-boolean">&para;</a> <a href="#top">&uarr;</a></span></h3>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:as </td><td>
<p>Can be set to :select, :radio, or :checkbox.  :select will use a select input with three options, a blank option, a true option, and a false option.  :radio will use two radio inputs, one for true and one for false.  :checkbox will use a single checkbox input. By default, uses :select if NULL values are allowed and the option is not required, and :checkbox otherwise.</p>
</td></tr><tr><td class='label'>:false_label </td><td>
<p>The value to use for the false label, â€˜Noâ€™ by default.</p>
</td></tr><tr><td class='label'>:false_value </td><td>
<p>The value to use for the false input, â€˜fâ€™ by default.</p>
</td></tr><tr><td class='label'>:true_label </td><td>
<p>The value to use for the true label, â€˜Yesâ€™ by default.</p>
</td></tr><tr><td class='label'>:true_value </td><td>
<p>The value to use for the true input, â€˜tâ€™ by default.</p>
</td></tr></tbody></table>

<h3 id="label-string">string<span><a href="#label-string">&para;</a> <a href="#top">&uarr;</a></span></h3>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:as </td><td>
<p>Can be set to :textarea to use a textarea input. You can use the usual attributes hash or a stylesheet to  control the size of the textarea.</p>
</td></tr></tbody></table>

<h2 id="label-associations">associations<span><a href="#label-associations">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The <a href="../classes/Sequel.html"><code>Sequel</code></a> support also handles associations, allowing you to change which objects are associated to the current object.</p>

<pre class="ruby"><span class="ruby-constant">Forme</span>.<span class="ruby-identifier">form</span>(<span class="ruby-constant">Album</span>[<span class="ruby-value">1</span>], <span class="ruby-value">:action</span><span class="ruby-operator">=&gt;</span><span class="ruby-string">&#39;/foo&#39;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:name</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:artist</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:tags</span>, <span class="ruby-value">:as</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">:checkbox</span>
<span class="ruby-keyword">end</span>
</pre>

<p>This will create a form similar to:</p>

<pre>&lt;form action=&quot;/foo&quot; method=&quot;post&quot;&gt;
  &lt;label&gt;Name: &lt;input id=&quot;album_name&quot; name=&quot;album[name]&quot; type=&quot;text&quot; value=&quot;Blue Hawaii&quot;/&gt;&lt;/label&gt;
  &lt;label&gt;Artist: &lt;select id=&quot;album_artist_id&quot; name=&quot;album[artist_id]&quot;&gt;
    &lt;option selected=&quot;selected&quot; value=&quot;1&quot;&gt;Elvis Presley&lt;/option&gt;
    &lt;option value=&quot;2&quot;&gt;The Beatles&lt;/option&gt;
    &lt;option value=&quot;3&quot;&gt;The Monkeys&lt;/option&gt;
  &lt;/select&gt;&lt;/label&gt;
  &lt;span class=&quot;label&quot;&gt;Tags:
    &lt;label&gt;&lt;input checked=&quot;checked&quot; id=&quot;album_tag_pks_1&quot; name=&quot;album[tag_pks][]&quot; type=&quot;checkbox&quot; value=&quot;1&quot;/&gt; Rock and Roll&lt;/label&gt;
    &lt;label&gt;&lt;input id=&quot;album_tag_pks_2&quot; name=&quot;album[tag_pks][]&quot; type=&quot;checkbox&quot; value=&quot;2&quot;/&gt; Blues&lt;/label&gt;
    &lt;label&gt;&lt;input id=&quot;album_tag_pks_3&quot; name=&quot;album[tag_pks][]&quot; type=&quot;checkbox&quot; value=&quot;3&quot;/&gt; Country&lt;/label&gt;
  &lt;/span&gt;
&lt;/form&gt;</pre>

<p>For one_to_many and many_to_many associations, you will probably want to use the <code>association_pks</code> plugin that ships with <a href="../classes/Sequel.html"><code>Sequel</code></a>.</p>

<p>This also supports the pg_array_to_many association type that comes with Sequelâ€™s <code>pg_array_association</code> plugin.</p>

<p>association input options:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:as </td><td>
<p>For many_to_one associations, set to :radio to use a series of radio buttons instead a select input.  For one_to_many, many_to_many, and pg_array_to_many associations, set to :checkbox to use a series of checkboxes instead of a multiple select input.</p>
</td></tr><tr><td class='label'>:dataset </td><td>
<p>If a Dataset, uses the dataset to retrieve the options.  If a Proc or Method, calls the proc or method with the default dataset, and should return a modified dataset to use.</p>
</td></tr><tr><td class='label'>:options </td><td>
<p>Specify the options to use for the input(s), instead of querying the database.</p>
</td></tr><tr><td class='label'>:name_method </td><td>
<p>If a String or Symbol, treats it as a method name and calls it on each object returned by the dataset to get the text to use for the option. If not given, tries the following method names in order: :forme_name, :name, :title, :number. If given and not a String or Symbol, a callable object is assumed, and the value is called with each object and should return the text to use for the option.</p>
</td></tr></tbody></table>

<h2 id="label-subform">subform<span><a href="#label-subform">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The <a href="../classes/Sequel.html"><code>Sequel</code></a> support includes a method called subform, which can handle nested_attributes:</p>

<pre class="ruby"><span class="ruby-constant">Forme</span>.<span class="ruby-identifier">form</span>(<span class="ruby-constant">Album</span>[<span class="ruby-value">1</span>], <span class="ruby-value">:action</span><span class="ruby-operator">=&gt;</span><span class="ruby-string">&#39;/foo&#39;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>

  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:name</span>

  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">subform</span> <span class="ruby-value">:artist</span> <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:name</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">subform</span> <span class="ruby-value">:tracks</span> <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:number</span>
    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:name</span>
  <span class="ruby-keyword">end</span>

<span class="ruby-keyword">end</span>
</pre>

<p>This adds an input for editing the artistâ€™s name after the albumâ€™s inputs, as well as inputs for editing the number and name for all of the tracks in the album, creating a form similar to:</p>

<pre>&lt;form action=&quot;/foo&quot; method=&quot;post&quot;&gt;

  &lt;label&gt;Name: &lt;input id=&quot;album_name&quot; name=&quot;album[name]&quot; type=&quot;text&quot; value=&quot;Blue Hawaii&quot;/&gt;&lt;/label&gt;

  &lt;input id=&quot;album_artist_attributes_id&quot; name=&quot;album[artist_attributes][id]&quot; type=&quot;hidden&quot; value=&quot;1&quot;/&gt;
  &lt;fieldset class=&quot;inputs&quot;&gt;&lt;legend&gt;Artist&lt;/legend&gt;
    &lt;label&gt;Name: &lt;input id=&quot;album_artist_attributes_name&quot; name=&quot;album[artist_attributes][name]&quot; type=&quot;text&quot; value=&quot;Elvis Presley&quot;/&gt;&lt;/label&gt;
  &lt;/fieldset&gt;

  &lt;input id=&quot;album_tracks_attributes_0_id&quot; name=&quot;album[tracks_attributes][0][id]&quot; type=&quot;hidden&quot; value=&quot;1&quot;/&gt;
  &lt;fieldset class=&quot;inputs&quot;&gt;&lt;legend&gt;Track #1&lt;/legend&gt;
    &lt;label&gt;Number: &lt;input id=&quot;album_tracks_attributes_0_number&quot; inputmode=&quot;numeric&quot; name=&quot;album[tracks_attributes][0][number]&quot; pattern=&quot;-?[0-9]*&quot; type=&quot;text&quot; value=&quot;1&quot;/&gt;&lt;/label&gt;
    &lt;label&gt;Name: &lt;input id=&quot;album_tracks_attributes_0_name&quot; name=&quot;album[tracks_attributes][0][name]&quot; type=&quot;text&quot; value=&quot;Blue Hawaii&quot;/&gt;&lt;/label&gt;
  &lt;/fieldset&gt;
  &lt;input id=&quot;album_tracks_attributes_1_id&quot; name=&quot;album[tracks_attributes][1][id]&quot; type=&quot;hidden&quot; value=&quot;2&quot;/&gt;
  &lt;fieldset class=&quot;inputs&quot;&gt;&lt;legend&gt;Track #2&lt;/legend&gt;
    &lt;label&gt;Number: &lt;input id=&quot;album_tracks_attributes_1_number&quot; inputmode=&quot;numeric&quot; name=&quot;album[tracks_attributes][1][number]&quot; pattern=&quot;-?[0-9]*&quot; type=&quot;text&quot; value=&quot;2&quot;/&gt;&lt;/label&gt;
    &lt;label&gt;Name: &lt;input id=&quot;album_tracks_attributes_1_name&quot; name=&quot;album[tracks_attributes][1][name]&quot; type=&quot;text&quot; value=&quot;Almost Always True&quot;/&gt;&lt;/label&gt;
  &lt;/fieldset&gt;

&lt;/form&gt;</pre>

<p><em>Note: blank lines added for clarity; they would not appear in the actual output</em></p>

<p>subform options:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:inputs </td><td>
<p>Automatically call <code>inputs</code> with the given values.  Using this, it is not required to pass a block to the method, though it will still work if you do.</p>
</td></tr><tr><td class='label'>:inputs_opts </td><td>
<p>When using the :grid option, this allows you to specify options to pass to the table InputsWrapper.</p>
</td></tr><tr><td class='label'>:legend </td><td>
<p>Overrides the default :legend used (which is based on the association name).  You can also use a proc as the value, which will called with each associated object (and the position in the associated object already for *_to_many associations), and should return the legend string to use for that object.</p>
</td></tr><tr><td class='label'>:grid </td><td>
<p>Sets up a table with one row per associated object, and one column per field.</p>
</td></tr><tr><td class='label'>:labels </td><td>
<p>When using the :grid option, override the labels that would be created via the :inputs option.  If you are not providing an :inputs option or are using a block with additional inputs, you should specify this option.</p>
</td></tr><tr><td class='label'>:skip_primary_key </td><td>
<p>Skip adding a hidden primary key field for existing objects.</p>
</td></tr></tbody></table>

<h2 id="label-Handling+form+submissions">Handling form submissions<span><a href="#label-Handling+form+submissions">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The <a href="../classes/Sequel.html"><code>Sequel</code></a> forme plugin only handles creating the forms, it does not handle processing input submitted via forms.  For a form such as:</p>

<pre class="ruby"><span class="ruby-constant">Forme</span>.<span class="ruby-identifier">form</span>(<span class="ruby-constant">Album</span>[<span class="ruby-value">1</span>], <span class="ruby-value">:action</span><span class="ruby-operator">=&gt;</span><span class="ruby-string">&#39;/foo&#39;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:name</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:copies_sold</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Input of the form will often be submitted as the following parameter hash (this depends on your web framework, but Rack works this way by default):</p>

<pre class="ruby">{<span class="ruby-string">&#39;album&#39;</span><span class="ruby-operator">=&gt;</span>{<span class="ruby-string">&#39;name&#39;</span><span class="ruby-operator">=&gt;</span><span class="ruby-string">&#39;Rising Force&#39;</span>, <span class="ruby-string">&#39;copies_sold&#39;</span><span class="ruby-operator">=&gt;</span><span class="ruby-string">&#39;100000&#39;</span>}}
</pre>

<p>One way to handle the form submission is to use Sequel::Model#set_fields.</p>

<pre class="ruby"><span class="ruby-identifier">album</span> = <span class="ruby-constant">Album</span>[<span class="ruby-value">1</span>]
<span class="ruby-identifier">album</span>.<span class="ruby-identifier">set_fields</span>(<span class="ruby-identifier">params</span>[<span class="ruby-string">&#39;album&#39;</span>], <span class="ruby-node">%w&#39;name copies_sold&#39;</span>)
<span class="ruby-identifier">album</span>.<span class="ruby-identifier">save</span>
</pre>

<p>Note that you have to specify the parameter names again as the second argument to set_fields.</p>

<p>Handling submitted parameters becomes more complex as your forms become more complex. For example, if you are only displaying certain form fields in certain situations:</p>

<pre class="ruby"><span class="ruby-identifier">album</span> = <span class="ruby-constant">Album</span>[<span class="ruby-value">1</span>]
<span class="ruby-constant">Forme</span>.<span class="ruby-identifier">form</span>(<span class="ruby-identifier">album</span>, <span class="ruby-value">:action</span><span class="ruby-operator">=&gt;</span><span class="ruby-string">&#39;/foo&#39;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:name</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:copies_sold</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">album</span>.<span class="ruby-identifier">released?</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Then your parameter handling becomes more complex:</p>

<pre class="ruby"><span class="ruby-identifier">album</span> = <span class="ruby-constant">Album</span>[<span class="ruby-value">1</span>]
<span class="ruby-identifier">album</span>.<span class="ruby-identifier">set_fields</span>(<span class="ruby-identifier">params</span>[<span class="ruby-string">&#39;album&#39;</span>], <span class="ruby-node">%w&#39;name&#39;</span>)
<span class="ruby-identifier">album</span>.<span class="ruby-identifier">set_fields</span>(<span class="ruby-identifier">params</span>[<span class="ruby-string">&#39;album&#39;</span>], <span class="ruby-node">%w&#39;copies_sold&#39;</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">album</span>.<span class="ruby-identifier">released?</span>
<span class="ruby-identifier">album</span>.<span class="ruby-identifier">save</span>
</pre>

<p>As you can see, you basically need to recreate the conditionals used when creating the form, so that that the processing of the form submission handles only the inputs that were displayed on the form.</p>

<h3 id="label-Sequel+forme_set+plugin"><a href="../classes/Sequel.html"><code>Sequel</code></a> forme_set plugin<span><a href="#label-Sequel+forme_set+plugin">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>The <a href="../classes/Sequel.html"><code>Sequel</code></a> forme_set plugin is designed to make handling form submissions easier.  What it does is record the form fields that are used on the object, and then it uses those fields to handle input submitted for the object.  For example:</p>

<pre class="ruby"><span class="ruby-identifier">album</span> = <span class="ruby-constant">Album</span>[<span class="ruby-value">1</span>]
<span class="ruby-constant">Forme</span>.<span class="ruby-identifier">form</span>(<span class="ruby-identifier">album</span>, <span class="ruby-value">:action</span><span class="ruby-operator">=&gt;</span><span class="ruby-string">&#39;/foo&#39;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:name</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:copies_sold</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">album</span>.<span class="ruby-identifier">released?</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">album</span>.<span class="ruby-identifier">forme_set</span>(<span class="ruby-identifier">params</span>[<span class="ruby-string">&#39;album&#39;</span>])
</pre>

<p>If the album has been released, and the form would display the name and copies_sold inputs, then forme_set will accept input for both.  If the album has not been released, the form will only display the name input, so forme_set will only accept the name input.</p>

<p>So forme_set offers two advantages over using set_fields:</p>
<ol><li>
<p>DRYs up code as you donâ€™t have to specify the names twice</p>
</li><li>
<p>Simplifies complex form submissions by eliminating duplication of conditionals</p>
</li></ol>

<h4 id="label-Validations">Validations<span><a href="#label-Validations">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>forme_set offers one additional advantage over using set_fields.  When dealing with associations, set_fields does not check that the value submitted for an input matches one of the available options displayed on the form.  For example, if you have a form such as:</p>

<pre class="ruby"><span class="ruby-constant">Forme</span>.<span class="ruby-identifier">form</span>(<span class="ruby-identifier">album</span>, <span class="ruby-value">:action</span><span class="ruby-operator">=&gt;</span><span class="ruby-string">&#39;/foo&#39;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:name</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:artist</span>, <span class="ruby-value">:dataset</span><span class="ruby-operator">=&gt;</span><span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">name</span> <span class="ruby-operator">&gt;</span> <span class="ruby-string">&#39;M&#39;</span>}}
<span class="ruby-keyword">end</span>
</pre>

<p>The form will only display artists whose name is greater than â€˜Mâ€™.  However, if you process input using:</p>

<pre class="ruby"><span class="ruby-identifier">album</span>.<span class="ruby-identifier">set_fields</span>(<span class="ruby-identifier">params</span>[<span class="ruby-string">&#39;album&#39;</span>], <span class="ruby-node">%w&#39;name artist_id&#39;</span>)
</pre>

<p>Then a malicious user can submit an artist_id for an artist whose name is not greater than â€˜Mâ€™, and the value will be set.  In addition to setting values, forme_set also adds validations that the submitted values for associated objects match one of the options displayed on the form, which can increase security.</p>

<h4 id="label-Usage">Usage<span><a href="#label-Usage">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Because forme_set relies on creating form inputs using the same model instance that will be used for accepting input, using it often requires some code rearranging.  If you are storing <a href="../classes/Forme/Form.html"><code>Forme::Form</code></a> objects and later using them on forms, it is fairly simple to move the <a href="../classes/Forme.html"><code>Forme::Forme</code></a> object creation to a method, that you can call both in the initial display and when processing the input:</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">album_form</span>(<span class="ruby-identifier">album</span>)
  <span class="ruby-constant">Forme</span>.<span class="ruby-identifier">form</span>(<span class="ruby-identifier">album</span>, <span class="ruby-value">:action</span><span class="ruby-operator">=&gt;</span><span class="ruby-string">&#39;/foo&#39;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:name</span>
    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:copies_sold</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Then when displaying the form:</p>

<pre>&lt;%= album_form(Album[1]) %&gt;</pre>

<p>and when processing the formâ€™s input:</p>

<pre class="ruby"><span class="ruby-identifier">album</span> = <span class="ruby-constant">Album</span>[<span class="ruby-value">1</span>]
<span class="ruby-identifier">album_form</span>(<span class="ruby-identifier">album</span>)
<span class="ruby-identifier">album</span>.<span class="ruby-identifier">forme_set</span>(<span class="ruby-identifier">params</span>[<span class="ruby-string">&#39;album&#39;</span>])
</pre>

<p>However, if you use Formeâ€™s ERB/Rails template integration (see below), and are inlining forms in your templates, unless you want to extract the <a href="../classes/Forme/Form.html"><code>Forme::Form</code></a> creation to methods, you have to basically rerender the template when processing the input.  How you do this is specific to the web framework you are using, but is it similar to:</p>

<pre class="ruby"><span class="ruby-ivar">@album</span> = <span class="ruby-constant">Album</span>[<span class="ruby-value">1</span>]
<span class="ruby-identifier">render</span> <span class="ruby-value">:template</span>
<span class="ruby-ivar">@album</span>.<span class="ruby-identifier">forme_set</span>(<span class="ruby-identifier">params</span>[<span class="ruby-string">&#39;album&#39;</span>])
</pre>

<h4 id="label-Caveats">Caveats<span><a href="#label-Caveats">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>forme_set is not perfect, there are ways to use <a href="../classes/Forme.html"><code>Forme</code></a> that forme_set will not handle correctly.  First, forme_set only works with forms that use model objects, and doesnâ€™t handle inputs where the <code>:obj</code> option is provided to change the input. Additionally, forme_set does not currently handle subform/nested_attributes.</p>

<p>In cases where forme_set does not handle things correctly, you can use <code>forme_parse</code>, which will return metadata that <code>forme_set</code> uses (<code>forme_set</code> calls <code>forme_parse</code> internally).  <code>forme_parse</code> returns a hash with the following keys:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:values </td><td>
<p>A hash of values that can be used to update the model, suitable for passing to Sequel::Model#set.</p>
</td></tr><tr><td class='label'>:validations </td><td>
<p>A hash of values suitable for merging into forme_validations. Used to check that the submitted values for associated objects match one of the options for the input in the form.</p>
</td></tr></tbody></table>

<p>It is possible to use <code>forme_set</code> for the values it can handle, and set other fields manually using <code>set_fields</code>.</p>

<h3 id="label-Roda+forme_set+plugin"><a href="../classes/Roda.html"><code>Roda</code></a> forme_set plugin<span><a href="#label-Roda+forme_set+plugin">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>The <a href="../classes/Roda.html"><code>Roda</code></a> forme_set plugin builds on the <a href="../classes/Sequel.html"><code>Sequel</code></a> forme_set plugin and is designed to make handling form submissions even easier. This plugin adds a hidden form input to store which fields were used to build the form, as well as some other metadata.  It adds another hidden form input with an HMAC, so that on submission, if the HMAC matches, you can be sure that an attacker didnâ€™t add extra fields.</p>

<p>There are a couple advantages to this plugin over using just the <a href="../classes/Sequel.html"><code>Sequel</code></a> forme_set plugin. One is that you do not need to record the form fields when processing the submission of a form, since the information you need is included in the form submission. Another is that calling the <code>forme_set</code> method is simpler, since it can determine the necessary parameters.</p>

<p>While you need code like this when using just the <a href="../classes/Sequel.html"><code>Sequel</code></a> forme_set plugin:</p>

<pre class="ruby"><span class="ruby-identifier">album</span> = <span class="ruby-constant">Album</span>[<span class="ruby-value">1</span>]
<span class="ruby-constant">Forme</span>.<span class="ruby-identifier">form</span>(<span class="ruby-identifier">album</span>, <span class="ruby-value">:action</span><span class="ruby-operator">=&gt;</span><span class="ruby-string">&#39;/foo&#39;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:name</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:copies_sold</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">album</span>.<span class="ruby-identifier">released?</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">album</span>.<span class="ruby-identifier">forme_set</span>(<span class="ruby-identifier">params</span>[<span class="ruby-string">&#39;album&#39;</span>])
</pre>

<p>when you also use the <a href="../classes/Roda.html"><code>Roda</code></a> forme_set plugin, you can simplify it to:</p>

<pre class="ruby"><span class="ruby-identifier">album</span> = <span class="ruby-constant">Album</span>[<span class="ruby-value">1</span>]
<span class="ruby-identifier">forme_set</span>(<span class="ruby-identifier">album</span>)
</pre>

<h4 id="label-Validations">Validations<span><a href="#label-Validations">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>The <a href="../classes/Roda.html"><code>Roda</code></a> forme_set plugin supports and uses the same validations as the <a href="../classes/Sequel.html"><code>Sequel</code></a> forme_set plugin.  However, the <a href="../classes/Roda.html"><code>Roda</code></a> plugin is more accurate because it uses the options that were present on the form when it was originally built, instead of the options that would be present on the form when the form was submitted.  However, note that that can be a negative if you are dynamically adding values to both the database and the form between when the form was built and when it was submitted.</p>

<h4 id="label-Usage">Usage<span><a href="#label-Usage">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Because the <a href="../classes/Roda.html"><code>Roda</code></a> forme_set plugin includes the metadata needed to process the form in form submissions, you donâ€™t need to rearrange code to use it, or rerender templates. You can do:</p>

<pre class="ruby"><span class="ruby-identifier">album</span> = <span class="ruby-constant">Album</span>[<span class="ruby-value">1</span>]
<span class="ruby-identifier">forme_set</span>(<span class="ruby-identifier">album</span>)
</pre>

<p>And the method will update the <code>album</code> object using the appropriate form values. </p>

<p>Note that using the <a href="../classes/Roda.html"><code>Roda</code></a> forme_set plugin requires you set a secret for the HMAC.  It is important that you keep this value secret, because if an attacker has access to this, they would be able to set arbitrary attributes for model objects.  In your <a href="../classes/Roda.html"><code>Roda</code></a> class, you can load the plugin via:</p>

<pre class="ruby"><span class="ruby-identifier">plugin</span> <span class="ruby-value">:forme_set</span>, <span class="ruby-value">:secret</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-constant">ENV</span>[<span class="ruby-string">&quot;APP_FORME_HMAC_SECRET&quot;</span>]
</pre>

<p>By default, invalid form submissions will raise an exception.  If you want to change that behavior (i.e. to display a nice error page), pass a block when loading the plugin:</p>

<pre class="ruby"><span class="ruby-identifier">plugin</span> <span class="ruby-value">:forme_set</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">error_type</span>, <span class="ruby-identifier">obj</span><span class="ruby-operator">|</span>
  <span class="ruby-comment"># ...</span>
<span class="ruby-keyword">end</span>
</pre>

<p>The block arguments will be a symbol for the type of error (:missing_data, :missing_hmac, :hmac_mismatch, :csrf_mismatch, or :missing_namespace) and the object passed to <code>forme_set</code>. This block should raise or halt.  If it does not, the default behavior of raising an exception will be taken.</p>

<h3 id="label-Form+Versions">Form Versions<span><a href="#label-Form+Versions">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>The <a href="../classes/Roda.html"><code>Roda</code></a> forme_set plugin supports form versions.  This allows you to gracefully handle changes to forms, processing submissions of the form generated before the change (if possible) as well as the processing submissions of the form generated after the change.</p>

<p>For example, maybe you have an existing form with just an input for the name:</p>

<pre class="ruby"><span class="ruby-identifier">form</span>(<span class="ruby-identifier">album</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span>(<span class="ruby-value">:name</span>)
<span class="ruby-keyword">end</span>
</pre>

<p>Then later, you want to add an input for the number of copies sold:</p>

<pre class="ruby"><span class="ruby-identifier">form</span>(<span class="ruby-identifier">album</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span>(<span class="ruby-value">:name</span>)
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span>(<span class="ruby-value">:copies_sold</span>)
<span class="ruby-keyword">end</span>
</pre>

<p>Using the <a href="../classes/Roda.html"><code>Roda</code></a> forme_set plugin, submissions of the old form would only set the name field, it wouldnâ€™t set the copies_sold field, since when the form was created, only the name field was used.</p>

<p>You can handle this case be versioning the form when making changes to it:</p>

<pre class="ruby"><span class="ruby-identifier">form</span>(<span class="ruby-identifier">album</span>, {}, <span class="ruby-value">:form_version</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">1</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span>(<span class="ruby-value">:name</span>)
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span>(<span class="ruby-value">:copies_sold</span>)
<span class="ruby-keyword">end</span>
</pre>

<p>When you are processing the form submission with forme_set, you pass a block, which will be yielded the version for the form (nil if no version was set):</p>

<pre class="ruby"><span class="ruby-identifier">forme_set</span>(<span class="ruby-identifier">album</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">version</span><span class="ruby-operator">|</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">version</span> <span class="ruby-operator">==</span> <span class="ruby-keyword">nil</span>
    <span class="ruby-identifier">album</span>.<span class="ruby-identifier">copies_sold</span> = <span class="ruby-value">0</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>The block is also yielded the object passed for forme_set, useful if you donâ€™t keep a reference to it:</p>

<pre class="ruby"><span class="ruby-identifier">album</span> = <span class="ruby-identifier">forme_set</span>(<span class="ruby-constant">Album</span>.<span class="ruby-identifier">new</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">version</span>, <span class="ruby-identifier">obj</span><span class="ruby-operator">|</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">version</span> <span class="ruby-operator">==</span> <span class="ruby-keyword">nil</span>
    <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">copies_sold</span> = <span class="ruby-value">0</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>You only need to support old versions of the form for as long as their could be active sessions that could use the old versions of the form.  As long you as are expiring sessions to prevent session fixation, you can remove the version handling after the expiration period has passed since the change to the form was made.</p>

<p>Note that this issue with handling changes to forms is not specific to the <a href="../classes/Roda.html"><code>Roda</code></a> forme_set plugin, it affects pretty much all form submissions.  The <a href="../classes/Roda.html"><code>Roda</code></a> forme_set plugin just makes this issue easier to handle.</p>

<h4 id="label-Caveats">Caveats<span><a href="#label-Caveats">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>The <a href="../classes/Roda.html"><code>Roda</code></a> forme_set plugin has basically the same caveats as <a href="../classes/Sequel.html"><code>Sequel</code></a> forme_set plugin. Additionally, it has a couple other restrictions that the <a href="../classes/Sequel.html"><code>Sequel</code></a> forme_set plugin does not have.</p>

<p>First, the <a href="../classes/Roda.html"><code>Roda</code></a> forme_set plugin only handles a single object in forms, which must be provided when creating the form.  It does not handle multiple objects in the same form, and ignores any fields set for an object different from the one passed when creating the form.  You can use the <a href="../classes/Sequel.html"><code>Sequel</code></a> forme_set plugin to handle form submissions involving multiple objects, or for the objects that were not passed when creating the form.</p>

<p>Second, the <a href="../classes/Roda.html"><code>Roda</code></a> forme_set plugin does not handle cases where the field values are placed outside the formâ€™s default namespace.  The <a href="../classes/Sequel.html"><code>Sequel</code></a> forme_set plugin can handle those issues, as long as all values are in the same namespace, since the <a href="../classes/Sequel.html"><code>Sequel</code></a> forme_set plugin requires you pass in the specific hash to use (the <a href="../classes/Roda.html"><code>Roda</code></a> forme_set plugin uses the formâ€™s namespace information and the submitted parameters to determine the hash to use).</p>

<p>In cases where the <a href="../classes/Roda.html"><code>Roda</code></a> forme_set does not handle things correctly, you can use forme_parse, which will return metadata in the same format as the <a href="../classes/Sequel.html"><code>Sequel</code></a> plugin forme_parse method, with the addition of a <code>:form_version</code> key in the hash for the form version.</p>

<p>It is possible to use the <a href="../classes/Roda.html"><code>Roda</code></a> forme_set plugin for the submissions it can handle, the <a href="../classes/Sequel.html"><code>Sequel</code></a> forme_set plugin for the submissions it can handle, and set other fields manually using the <a href="../classes/Sequel.html"><code>Sequel</code></a> <code>set_fields</code> methods.</p>

<p>Note that when using the <a href="../classes/Roda.html"><code>Roda</code></a> forme_set plugin with an existing form, you should first enable the <a href="../classes/Roda.html"><code>Roda</code></a> plugin without actually using the <a href="../classes/Roda.html"><code>Roda</code></a> forme_set method.  Do not start using the <a href="../classes/Roda.html"><code>Roda</code></a> forme_set method until all currently valid sessions were established after the <a href="../classes/Roda.html"><code>Roda</code></a> forme_set plugin was enabled.  Otherwise, sessions that access the form before the <a href="../classes/Roda.html"><code>Roda</code></a> forme_set plugin was enabled will not work if they submit the form after the <a href="../classes/Roda.html"><code>Roda</code></a> forme_set plugin is enabled.</p>

<h2 id="label-Other+Sequel+Plugins">Other <a href="../classes/Sequel.html"><code>Sequel</code></a> Plugins<span><a href="#label-Other+Sequel+Plugins">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>In addition to the <a href="../classes/Sequel.html"><code>Sequel</code></a> plugins mentioned above, <a href="../classes/Forme.html"><code>Forme</code></a> also ships with additional <a href="../classes/Sequel.html"><code>Sequel</code></a> plugins:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>forme_i18n </td><td>
<p>Handles translations for labels using i18n.</p>
</td></tr></tbody></table>

<h1 id="label-Roda+Support"><a href="../classes/Roda.html"><code>Roda</code></a> Support<span><a href="#label-Roda+Support">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p><a href="../classes/Forme.html"><code>Forme</code></a> ships with multiple <a href="../classes/Roda.html"><code>Roda</code></a> plugins</p>
<ul><li>
<p>forme_set (discussed above)</p>
</li><li>
<p>forme</p>
</li><li>
<p>forme_route_csrf</p>
</li><li>
<p>forme_erubi_capture</p>
</li></ul>

<h2 id="label-forme_route_csrf+and+forme+plugins">forme_route_csrf and forme plugins<span><a href="#label-forme_route_csrf+and+forme+plugins">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>For new code, it is recommended to use forme_route_csrf, as that uses Rodaâ€™s route_csrf plugin, which supports more secure request-specific CSRF tokens.  In both cases, usage in ERB templates is the same:</p>

<pre>&lt;% form(@obj, :action=&gt;&#39;/foo&#39;) do |f| %&gt;
  &lt;%= f.input(:field) %&gt;
  &lt;% f.tag(:fieldset) do %&gt;
    &lt;%= f.input(:field_two) %&gt;
  &lt;% end %&gt;
&lt;% end %&gt;</pre>

<p>The forme_route_csrf pluginâ€™s <code>form</code> method supports the following options in addition to the default <code>Forme.form</code> options:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:csrf </td><td>
<p>Set to force whether a CSRF tag should be included.  By default, a CSRF tag is included if the formâ€™s method is one of the request methods checked by the <a href="../classes/Roda.html"><code>Roda</code></a> route_csrf plugin.</p>
</td></tr><tr><td class='label'>:use_request_specific_token </td><td>
<p>Set whether to force the use of a request specific CSRF token.  By default, uses a request specific CSRF token unless the <a href="../classes/Roda.html"><code>Roda</code></a> route_csrf plugin has been configured to support non-request specific tokens.</p>
</td></tr></tbody></table>

<p>The forme plugin does not require any csrf plugin, but will transparently use Rack::Csrf if it is available. If Rack::Csrf is available a CSRF tag if the formâ€™s method is <code>POST</code>, with no configuration ability.</p>

<h2 id="label-forme_erubi_capture+plugin">forme_erubi_capture plugin<span><a href="#label-forme_erubi_capture+plugin">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The forme_erubi_capture plugin builds on the forme_route_csrf plugin, but it supports the erubi/capture_end engine, which allows this syntax:</p>

<pre>&lt;%|= form(@obj, :action=&gt;&#39;/foo&#39;) do |f| %&gt;
  &lt;%= f.input(:field) %&gt;
  &lt;%|= f.tag(:fieldset) do %&gt;
    &lt;%= f.input(:field_two) %&gt;
  &lt;%| end %&gt;
&lt;%| end %&gt;</pre>

<p>If you use the forme_erubi_capture plugin, you need to manually set <a href="../classes/Roda.html"><code>Roda</code></a> to use the erubi/capture_end engine, which you can do via:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;erubi/capture_end&#39;</span>
<span class="ruby-identifier">app</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:render</span>, <span class="ruby-value">:engine_opts</span><span class="ruby-operator">=&gt;</span>{<span class="ruby-string">&#39;erb&#39;</span><span class="ruby-operator">=&gt;</span>{<span class="ruby-value">:engine_class</span><span class="ruby-operator">=&gt;</span><span class="ruby-constant">Erubi</span><span class="ruby-operator">::</span><span class="ruby-constant">CaptureEndEngine</span>}}
</pre>

<p>The forme_erubi_capture plugin requires <a href="../classes/Roda.html"><code>Roda</code></a> 3.50.0+.</p>

<h1 id="label-Sinatra+Support">Sinatra Support<span><a href="#label-Sinatra+Support">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p><a href="../classes/Forme.html"><code>Forme</code></a> ships with a Sinatra extension that you can get by <code>require &quot;forme/erb&quot;</code> and using <code>including Forme::ERB::Helper</code>.  This is tested to support ERB templates in Sinatra. It allows you to use the following API in your erb templates:</p>

<pre>&lt;% form(@obj, :action=&gt;&#39;/foo&#39;) do |f| %&gt;
  &lt;%= f.input(:field) %&gt;
  &lt;% f.tag(:fieldset) do %&gt;
    &lt;%= f.input(:field_two) %&gt;
  &lt;% end %&gt;
&lt;% end %&gt;</pre>

<p>In order to this to work transparently, the ERB outvar needs to be <code>@_out_buf</code> (this is the default in Sinatra).</p>

<h1 id="label-Rails+Support">Rails Support<span><a href="#label-Rails+Support">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p><a href="../classes/Forme.html"><code>Forme</code></a> ships with a Rails extension that you can get by <code>require &quot;forme/rails&quot;</code> and using <code>helper Forme::Rails::ERB</code> in your controller.  If allows you to use the following API in your Rails forms:</p>

<pre>&lt;%= forme(@obj, :action=&gt;&#39;/foo&#39;) do |f| %&gt;
  &lt;%= f.input(:field) %&gt;
  &lt;%= f.tag(:fieldset) do %&gt;
    &lt;%= f.input(:field_two) %&gt;
  &lt;% end %&gt;
&lt;% end %&gt;</pre>

<p>This has been tested on Rails 3.2-7.0.</p>

<h1 id="label-Input+Types+and+Options">Input Types and Options<span><a href="#label-Input+Types+and+Options">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>These are the types and options supported by <a href="../classes/Forme/Input.html"><code>Forme::Input</code></a> objects, usually created via <a href="../classes/Forme/Form.html#method-i-input"><code>Forme::Form#input</code></a>:</p>

<h2 id="label-General+Options">General Options<span><a href="#label-General+Options">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>These options are supported by all of the input types:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:attr </td><td>
<p>The attributes hash to use for the given tag, attributes in this hash take precedence over other options that set attributes.</p>
</td></tr><tr><td class='label'>:autofocus </td><td>
<p>Set the autofocus attribute if true</p>
</td></tr><tr><td class='label'>:class </td><td>
<p>A class to use.  Unlike other options, this is combined with the classes set in the :attr hash.</p>
</td></tr><tr><td class='label'>:dasherize_data </td><td>
<p>Automatically replace underscores with hyphens for symbol data attribute names in the <code>:data</code> hash. Defaults to <code>false</code>.</p>
</td></tr><tr><td class='label'>:data </td><td>
<p>A hash of data-* attributes for the resulting tag.  Keys in this hash will have attributes created with data- prepended to the attribute name.</p>
</td></tr><tr><td class='label'>:disabled </td><td>
<p>Set the disabled attribute if true</p>
</td></tr><tr><td class='label'>:error </td><td>
<p>Set an error message, invoking the error_handler</p>
</td></tr><tr><td class='label'>:error_handler </td><td>
<p>Set a custom error_handler, overriding the formâ€™s default</p>
</td></tr><tr><td class='label'>:help </td><td>
<p>Set help text to use, invoking the helper</p>
</td></tr><tr><td class='label'>:helper </td><td>
<p>Set a custom helper, overriding the formâ€™s default</p>
</td></tr><tr><td class='label'>:id </td><td>
<p>The id attribute to use</p>
</td></tr><tr><td class='label'>:key </td><td>
<p>The base to use for the name and id attributes, based on the current namespace for the form.</p>
</td></tr><tr><td class='label'>:label </td><td>
<p>Set a label, invoking the labeler</p>
</td></tr><tr><td class='label'>:labeler </td><td>
<p>Set a custom labeler, overriding the formâ€™s default</p>
</td></tr><tr><td class='label'>:name </td><td>
<p>The name attribute to use</p>
</td></tr><tr><td class='label'>:obj </td><td>
<p>Set the form object, overriding the formâ€™s default</p>
</td></tr><tr><td class='label'>:placeholder </td><td>
<p>The placeholder attribute to use</p>
</td></tr><tr><td class='label'>:required </td><td>
<p>Set the required attribute if true</p>
</td></tr><tr><td class='label'>:type </td><td>
<p>Override the type of the input when the form has an associated object but the object does not respond to <code>forme_input</code></p>
</td></tr><tr><td class='label'>:value </td><td>
<p>The value attribute to use for input tags, the content of the textarea for textarea tags, or the selected option(s) for select tags.</p>
</td></tr><tr><td class='label'>:wrapper </td><td>
<p>Set a custom wrapper, overriding the formâ€™s default</p>
</td></tr></tbody></table>

<h2 id="label-Input+Type-Specific+Options">Input Type-Specific Options<span><a href="#label-Input+Type-Specific+Options">&para;</a> <a href="#top">&uarr;</a></span></h2>

<h3 id="label-3Acheckbox">:checkbox<span><a href="#label-3Acheckbox">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Creates an input tag with type checkbox, as well as a hidden input tag. Options:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:checked </td><td>
<p>Mark the checkbox as checked.</p>
</td></tr><tr><td class='label'>:hidden_value </td><td>
<p>The value to use for the hidden input tag.</p>
</td></tr><tr><td class='label'>:no_hidden </td><td>
<p>Donâ€™t create a hidden input tag.</p>
</td></tr></tbody></table>

<h3 id="label-3Aradio">:radio<span><a href="#label-3Aradio">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Creates an input tag with type radio. Options:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:checked </td><td>
<p>Mark the radio button as checked.</p>
</td></tr></tbody></table>

<h3 id="label-3Adate+-2F+-3Adatetime">:date / :datetime<span><a href="#label-3Adate+-2F+-3Adatetime">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>By default, creates an input tag with type date or datetime.  With the <code>as: :select</code> option, creates multiple select options. Options:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:as </td><td>
<p>When value is :select, uses 3 or 6 select boxes by default.</p>
</td></tr><tr><td class='label'>:order </td><td>
<p>The order of select boxes when using <code>as: :select</code>.  Entries should be a symbol for the select field and string to use a string (:date default: <code>[:year, &#39;-&#39;, :month, &#39;-&#39;, :day]</code>) (:datetime default: <code>[:year, &#39;-&#39;, :month, &#39;-&#39;, :day, &#39; &#39;, :hour, &#39;:&#39;, :minute, &#39;:&#39;, :second]</code>)</p>
</td></tr><tr><td class='label'>:select_labels </td><td>
<p>The labels to use for the select boxes.  Should be a hash keyed by the symbol used (e.g. <code>{:month=&gt;&#39;Month&#39;}</code>).  By default, no labels are used.</p>
</td></tr><tr><td class='label'>:select_options </td><td>
<p>The options to use for the select boxes.  Should be a hash keyed by the symbol used in order (e.g. <code>{:year=&gt;1970..2020}</code>).  The values can be a number used as both the value and the text of the option or an array with two elements, the first of which is the value for the option and the second of which is the text for the option.</p>
</td></tr></tbody></table>

<h3 id="label-3Aselect">:select<span><a href="#label-3Aselect">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Creates a select tag, containing option tags specified by the :options option.  Options:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:add_blank </td><td>
<p>Add a blank option if true.  If the value is a string, use it as the text content of the blank option.  The default value can be set with <a href="../classes/Forme.html#attribute-c-default_add_blank_prompt"><code>Forme.default_add_blank_prompt</code></a>, and defaults to the empty string.</p>
</td></tr><tr><td class='label'>:blank_attr </td><td>
<p>If :add_blank is set, sets the attributes to use for the blank option.</p>
</td></tr><tr><td class='label'>:blank_position </td><td>
<p>If :add_blank is set, can be set to :after to add the prompt after the inputs, instead of before (which is the default).</p>
</td></tr><tr><td class='label'>:multiple </td><td>
<p>Creates a multiple select box.</p>
</td></tr><tr><td class='label'>:optgroups </td><td>
<p>An enumerable of pairs with the first element being option group labels or a hash of option group attributes, and values being enumerables of options (as described by :options below).  Creates optgroup tags around the appropriate options. This overrides any options specified via :options.</p>
</td></tr><tr><td class='label'>:options </td><td>
<p>An enumerable of options used for creating option tags. If the :text_method and :value_method are not given and the entry is an  array, uses the first entry of the array as the text of the option, and the last entry of the array as the value of the option. If the last entry of the array is a hash, uses the hash as the attributes for the option.</p>
</td></tr><tr><td class='label'>:selected </td><td>
<p>The value that should be selected.  Any options that are equal to this value (or included in this value if a multiple select box), are set to selected.</p>
</td></tr><tr><td class='label'>:size </td><td>
<p>Uses the size attribute on the tag</p>
</td></tr><tr><td class='label'>:text_method </td><td>
<p>If set, each entry in the array has this option called on it to get the text of the object.</p>
</td></tr><tr><td class='label'>:value </td><td>
<p>Same as :selected, but has lower priority.</p>
</td></tr><tr><td class='label'>:value_method </td><td>
<p>If set (and :text_method is set), each entry in the array has this method called on it to get the value of the option.</p>
</td></tr></tbody></table>

<h3 id="label-3Acheckboxset">:checkboxset<span><a href="#label-3Acheckboxset">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Creates a set of checkbox inputs all using the same name.  Supports the same options as the :select type, except that the :multiple option is assumed to be true.  Also supports the following options:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:tag_wrapper </td><td>
<p>The wrapper transformer for individual tags in the set</p>
</td></tr><tr><td class='label'>:tag_labeler </td><td>
<p>The labeler transformer for individual tags in the set</p>
</td></tr><tr><td class='label'>:tag_label_attr </td><td>
<p>The attributes to use for labels for individual tags in the set</p>
</td></tr></tbody></table>

<h3 id="label-3Aradioset">:radioset<span><a href="#label-3Aradioset">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Creates a set of radio buttons all using the same name.  Supports the same options as the :checkboxset type.</p>

<h3 id="label-3Atextarea">:textarea<span><a href="#label-3Atextarea">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Creates a textarea tag.  Options:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:cols </td><td>
<p>The number of columns in the text area.</p>
</td></tr><tr><td class='label'>:rows </td><td>
<p>The number of rows in the text area.</p>
</td></tr></tbody></table>

<h2 id="label-all+others">all others<span><a href="#label-all+others">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Creates an input tag with the given type. This makes it easy to use inputs such as text and password, as well as newer HTML5 inputs such as number or email. Options:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:size </td><td>
<p>Uses the size attribute on the tag</p>
</td></tr><tr><td class='label'>:maxlength </td><td>
<p>Use the maxlength attribute on the tag</p>
</td></tr></tbody></table>

<h2 id="label-Form+options">Form options<span><a href="#label-Form+options">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>These are the options supported by <a href="../classes/Forme/Form.html"><code>Forme::Form</code></a> object, mostly used to set the defaults for Inputs created via the form:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:after </td><td>
<p>A callable object that is yielded the Form instance after yielding to the block. Can be used to add hidden inputs to the end of the form.</p>
</td></tr><tr><td class='label'>:before </td><td>
<p>A callable object that is yielded the Form instance before yielding to</p>
</td></tr></tbody></table>

<pre>the block. Can be used to add hidden inputs to the start of the form.</pre>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:config </td><td>
<p>The configuration to use, which automatically sets defaults for the transformers to use.</p>
</td></tr><tr><td class='label'>:errors </td><td>
<p>A Hash of errors from a previous form submission, used to set default errors for inputs when the inputs use the :key option.</p>
</td></tr><tr><td class='label'>:error_handler </td><td>
<p>Sets the default error_handler for the formâ€™s inputs</p>
</td></tr><tr><td class='label'>:helper </td><td>
<p>Sets the default helper for the formâ€™s inputs</p>
</td></tr><tr><td class='label'>:formatter </td><td>
<p>Sets the default formatter for the formâ€™s inputs</p>
</td></tr><tr><td class='label'>:input_defaults </td><td>
<p>Sets the default options for each input type.  This should be a hash with input type keys, where the values are the hash of default options to use for the input type. </p>
</td></tr><tr><td class='label'>:inputs_wrapper </td><td>
<p>Sets the default inputs_wrapper for the form</p>
</td></tr><tr><td class='label'>:labeler </td><td>
<p>Sets the default labeler for the formâ€™s inputs</p>
</td></tr><tr><td class='label'>:namespace </td><td>
<p>Sets the default namespace(s) to use for the form.  Namespacing will automatically create namespaced name and id attributes for inputs that use the :key option.</p>
</td></tr><tr><td class='label'>:obj </td><td>
<p>Sets the default <code>obj</code> for the formâ€™s inputs.</p>
</td></tr><tr><td class='label'>:serializer </td><td>
<p>Sets the serializer for the form</p>
</td></tr><tr><td class='label'>:values </td><td>
<p>The values from a previous form submission, used to set default values for inputs when the inputs use the :key option.</p>
</td></tr><tr><td class='label'>:wrapper </td><td>
<p>Sets the default wrapper for the formâ€™s inputs</p>
</td></tr></tbody></table>

<p>For forms created by <a href="../classes/Forme.html#method-c-form"><code>Forme.form</code></a>, the following options are supported:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:inputs </td><td>
<p>An array of inputs to create inside the form, before yielding to the block.</p>
</td></tr><tr><td class='label'>:button </td><td>
<p>A button to add to the form, after yielding to the block.</p>
</td></tr></tbody></table>

<h1 id="label-Internal+Architecture">Internal Architecture<span><a href="#label-Internal+Architecture">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>Internally, <a href="../classes/Forme.html"><code>Forme</code></a> builds an abstract syntax tree of objects that represent the form.  The abstract syntax tree goes through a series of transformations that convert it from high level abstract forms to low level abstract forms and finally to strings.  Here are the main classes used by the library:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'><code>Forme::Form</code> </td><td>
<p>main object</p>
</td></tr><tr><td class='label'><code>Forme::Input</code> </td><td>
<p>high level abstract tag (a single <code>Input</code> could represent a select box with a bunch of options)</p>
</td></tr><tr><td class='label'><code>Forme::Tag</code> </td><td>
<p>low level abstract tag representing an HTML tag (there would be a separate <code>Tag</code> for each option in a select box)</p>
</td></tr></tbody></table>

<p>The difference between <code>Forme::Input</code> and <code>Forme::Tag</code>  is that <code>Forme::Tag</code> directly represents the underlying HTML tag, containing a type, optional attributes, and children, while the <code>Forme::Input</code> is more abstract and attempts to be user friendly. For example, these both compile by default to the same select tag:</p>

<pre class="ruby"><span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span>(<span class="ruby-value">:select</span>, <span class="ruby-value">:options</span><span class="ruby-operator">=&gt;</span>[[<span class="ruby-string">&#39;foo&#39;</span>, <span class="ruby-value">1</span>]])
<span class="ruby-comment"># or</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">tag</span>(<span class="ruby-value">:select</span>, {}, [<span class="ruby-identifier">f</span>.<span class="ruby-identifier">tag</span>(<span class="ruby-value">:option</span>, {<span class="ruby-value">:value</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">1</span>}, [<span class="ruby-string">&#39;foo&#39;</span>])])
</pre>

<p>The group of objects that perform the transformations to the abstract syntax trees are known as transformers. Transformers use a functional style, and all use a <code>call</code>-based API, so you can use a <code>Proc</code> for any custom transformer. The processing of high level <code>Forme::Input</code>s into raw HTML fragments is performed through the following transformers:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'><code>Formatter</code> </td><td>
<p>converts a <code>Forme::Input</code> instance into a <code>Forme::Tag</code> instance (or array of them).</p>
</td></tr><tr><td class='label'><code>ErrorHandler</code> </td><td>
<p>If the <code>Forme::Input</code> instance has a error, takes the formatted tag and marks it as having the error.</p>
</td></tr><tr><td class='label'><code>Helper</code> </td><td>
<p>If the <code>Forme::Input</code> instance has any help text, adds the help text in a separate tag.</p>
</td></tr><tr><td class='label'><code>Labeler</code> </td><td>
<p>If the <code>Forme::Input</code> instance has a label, takes the formatted output and labels it.</p>
</td></tr><tr><td class='label'><code>Wrapper</code> </td><td>
<p>Takes the output of the formatter, labeler, and error_handler transformers, and wraps it in another tag (or just returns it unmodified).</p>
</td></tr><tr><td class='label'><code>Serializer</code> </td><td>
<p>converts a <code>Forme::Tag</code> instance into an HTML string.</p>
</td></tr></tbody></table>

<p>Technically, only the <code>Serializer</code> is necessary.  The <a href="../classes/Forme/Form.html#method-i-input"><code>Forme::Form#input</code></a> and <a href="../classes/Forme/Form.html#method-i-tag"><code>Forme::Form#tag</code></a> methods internally create <code>Input</code> and <code>Tag</code> objects.  Before returning results, the input or tag is converted to a string using <code>to_s</code>, which calls the appropriate <code>Serializer</code>. The <code>Serializer</code> calls the appropriate <code>Formatter</code> if it encounters an <code>Input</code> instance, and attempts to serialize the output of that (which is usually a <code>Tag</code> instance).  It is up to the <code>Formatter</code> to call the <code>Labeler</code>, <code>ErrorHandler</code>, <code>Helper</code>, and/or <code>Wrapper</code>.</p>

<p>The <a href="../classes/Forme/Form.html"><code>Forme::Form</code></a> object takes the transformers as options (:formatter, :labeler, :error_handler, :helper, :wrapper, and :serializer), all of which should be objects responding to <code>call</code> (so you can use <code>Proc</code>s) or be symbols registered with the library using <code>Forme.register_transformer</code>:</p>

<pre class="ruby"><span class="ruby-constant">Forme</span>.<span class="ruby-identifier">register_transformer</span>(<span class="ruby-value">:wrapper</span>, <span class="ruby-value">:p</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">tag</span>, <span class="ruby-identifier">input</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">input</span>.<span class="ruby-identifier">tag</span>(<span class="ruby-value">:p</span>, {}, <span class="ruby-identifier">tag</span>)
<span class="ruby-keyword">end</span>
</pre>

<p>Most transformers are called with two arguments, <code>tag</code> and <code>input</code>.  <code>tag</code> is a <code>Forme::Tag</code> instance, and <code>input</code> is a <code>Forme::Input</code> instance.  The <code>Formatter</code> and <code>Serializer</code> transformers are the two exceptions, with <code>Formatter</code> being called with just an <code>input</code>, and <code>Serializer</code> potentionally being called with any object.  The <code>Serializer</code> will in general recursively call itself with children of the argument given until a string is returned.</p>

<p>There is also an <code>InputsWrapper</code> transformer, that is called by <a href="../classes/Forme/Form.html#method-i-inputs"><code>Forme::Form#inputs</code></a>.  Itâ€™s used to wrap up a group of related options (in a <code>fieldset</code> by default).  It takes <code>form</code> (<a href="../classes/Forme/Form.html"><code>Forme::Form</code></a> instance) and <code>input_opts</code> (<code>Hash</code>) arguments.</p>

<p>Most of the transformers can be overridden on a per instance basis by passing the appropriate option to <code>input</code> or <code>inputs</code>:</p>

<pre class="ruby"><span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span>(<span class="ruby-value">:name</span>, <span class="ruby-value">:wrapper</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">:p</span>)
</pre>

<p>Existing transformers can be easily extended (ie, to set the class attribute), by creating your own transformer and then calling the existing transformer.</p>

<pre class="ruby"><span class="ruby-constant">Forme</span>.<span class="ruby-identifier">register_transformer</span>(<span class="ruby-value">:labeler</span>, <span class="ruby-value">:explicit</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">tag</span>, <span class="ruby-identifier">input</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">input</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:label_attr</span>] <span class="ruby-operator">||=</span> { <span class="ruby-value">:class</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-string">&#39;label&#39;</span> }
  <span class="ruby-constant">Forme</span><span class="ruby-operator">::</span><span class="ruby-constant">Labeler</span><span class="ruby-operator">::</span><span class="ruby-constant">Explicit</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">tag</span>, <span class="ruby-identifier">input</span>)
<span class="ruby-keyword">end</span>
</pre>

<h2 id="label-Transformer+Types">Transformer Types<span><a href="#label-Transformer+Types">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>You can override the type of transform for each form or input using the following options:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'><code>serializer</code> </td><td>
<p>tags input/tag, returns string</p>
</td></tr><tr><td class='label'><code>formatter</code> </td><td>
<p>takes input, returns tag</p>
</td></tr><tr><td class='label'><code>error_handler</code> </td><td>
<p>takes tag and input, returns version of tag with errors noted</p>
</td></tr><tr><td class='label'><code>helper</code> </td><td>
<p>takes tag and input, returns version of tag with help added</p>
</td></tr><tr><td class='label'><code>labeler</code> </td><td>
<p>takes tag and input, returns labeled version of tag</p>
</td></tr><tr><td class='label'><code>wrapper</code> </td><td>
<p>takes tag and input, returns wrapped version of tag</p>
</td></tr><tr><td class='label'><code>inputs_wrapper</code> </td><td>
<p>takes form, options hash, and block, wrapping block in a tag</p>
</td></tr></tbody></table>

<p>The <code>serializer</code> is the base of the transformations.  It turns <code>Tag</code> instances into strings.  If it comes across an <code>Input</code>, it calls the <code>formatter</code> on the <code>Input</code> to turn it into a <code>Tag</code>, and then serializes that <code>Tag</code>.  The <code>formatter</code> first converts the <code>Input</code> to a <code>Tag</code>, and then calls the <code>labeler</code>  if the <code>:label</code> option is set, the <code>error_handler</code> if the <code>:error</code> option is set, and the <code>helper</code> if the <code>:help</code> option is set .  Finally, it calls the <code>wrapper</code> to wrap the resulting tag before returning it.</p>

<p>The <code>inputs_wrapper</code> is called by <code>Forme::Form#inputs</code> and serves to wrap a bunch of related inputs.</p>

<h2 id="label-Built-in+Transformers">Built-in Transformers<span><a href="#label-Built-in+Transformers">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><a href="../classes/Forme.html"><code>Forme</code></a> ships with a bunch of built-in transformers that you can use:</p>

<h3 id="label-serializer"><code>serializer</code><span><a href="#label-serializer">&para;</a> <a href="#top">&uarr;</a></span></h3>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:default </td><td>
<p>returns HTML strings</p>
</td></tr><tr><td class='label'>:html_usa </td><td>
<p>returns HTML strings, formats dates and times in American format without timezones</p>
</td></tr><tr><td class='label'>:text </td><td>
<p>returns plain text strings</p>
</td></tr></tbody></table>

<h3 id="label-formatter"><code>formatter</code><span><a href="#label-formatter">&para;</a> <a href="#top">&uarr;</a></span></h3>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:default </td><td>
<p>turns Inputs into Tags</p>
</td></tr><tr><td class='label'>:disabled </td><td>
<p>disables all resulting input tags</p>
</td></tr><tr><td class='label'>:readonly </td><td>
<p>uses <code>span</code> tags for most values, good for printable versions of forms</p>
</td></tr></tbody></table>

<h3 id="label-error_handler"><code>error_handler</code><span><a href="#label-error_handler">&para;</a> <a href="#top">&uarr;</a></span></h3>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:after_legend </td><td>
<p>designed for usage with :legend labeler, putting error message after legend, adding error for first input in the set</p>
</td></tr><tr><td class='label'>:default </td><td>
<p>modifies tag to add an error class and adds a span with the error message</p>
</td></tr><tr><td class='label'>:set </td><td>
<p>default error_handler for checkboxset and radioset inputs, that adds an error to the last input in the set</p>
</td></tr></tbody></table>

<p>This supports the following options:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:error_attr </td><td>
<p>A hash of attributes to use for the span with the error message</p>
</td></tr></tbody></table>

<h3 id="label-helper"><code>helper</code><span><a href="#label-helper">&para;</a> <a href="#top">&uarr;</a></span></h3>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:default </td><td>
<p>adds a span with the help text</p>
</td></tr></tbody></table>

<p>This supports the following options:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:helper_attr </td><td>
<p>A hash of attributes to use for the span with the help message</p>
</td></tr></tbody></table>

<h3 id="label-labeler"><code>labeler</code><span><a href="#label-labeler">&para;</a> <a href="#top">&uarr;</a></span></h3>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:default </td><td>
<p>uses implicit labels, where the tag is a child of the label tag</p>
</td></tr><tr><td class='label'>:explicit </td><td>
<p>uses explicit labels with the for attribute, where tag is a sibling of the label tag</p>
</td></tr><tr><td class='label'>:legend </td><td>
<p>adds a legend before the tags, mostly useful for accessible checkboxset and radioset inputs</p>
</td></tr><tr><td class='label'>:span </td><td>
<p>default labeler for checkboxset and radioset inputs that adds a span before the tags</p>
</td></tr></tbody></table>

<p>The :default and :explicit labelers respect the following options:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:label_position </td><td>
<p>Can be set to :before or :after to place the label before or after the the input.</p>
</td></tr><tr><td class='label'>:label_attr </td><td>
<p>A hash of attributes to use for the label tag</p>
</td></tr></tbody></table>

<h3 id="label-wrapper"><code>wrapper</code><span><a href="#label-wrapper">&para;</a> <a href="#top">&uarr;</a></span></h3>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:default </td><td>
<p>returns tag without wrapping</p>
</td></tr><tr><td class='label'>:div </td><td>
<p>wraps tag in div tag</p>
</td></tr><tr><td class='label'>:fieldset </td><td>
<p>wraps tags in a fieldset, mostly useful for accessible checkboxset and radioset inputs</p>
</td></tr><tr><td class='label'>:fieldset_ol </td><td>
<p>same as :li, but also sets <code>inputs_wrapper</code> to :fieldset_ol</p>
</td></tr><tr><td class='label'>:li </td><td>
<p>wraps tag in li tag</p>
</td></tr><tr><td class='label'>:ol </td><td>
<p>same as :li, but also sets <code>inputs_wrapper</code> to :ol</p>
</td></tr><tr><td class='label'>:p </td><td>
<p>wraps tag in p tag</p>
</td></tr><tr><td class='label'>:span </td><td>
<p>wraps tag in span tag</p>
</td></tr><tr><td class='label'>:table </td><td>
<p>same as :trtd, but also sets <code>inputs_wrapper</code> to :table</p>
</td></tr><tr><td class='label'>:td </td><td>
<p>wraps tag in a td tag</p>
</td></tr><tr><td class='label'>:tr </td><td>
<p>same as :td, but also sets <code>inputs_wrapper</code> to :tr</p>
</td></tr><tr><td class='label'>:trtd </td><td>
<p>wraps tag in a tr tag with a td for the label and a td for the tag, useful for lining up inputs with the :explicit labeler without CSS</p>
</td></tr></tbody></table>

<p>All of these except for :default respect the following options:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:wrapper_attr </td><td>
<p>A hash of attributes to use for the wrapping tag.</p>
</td></tr></tbody></table>

<h3 id="label-inputs_wrapper"><code>inputs_wrapper</code><span><a href="#label-inputs_wrapper">&para;</a> <a href="#top">&uarr;</a></span></h3>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:default </td><td>
<p>uses a fieldset to wrap inputs</p>
</td></tr><tr><td class='label'>:div </td><td>
<p>uses a div tag to wrap inputs</p>
</td></tr><tr><td class='label'>:fieldset_ol </td><td>
<p>use both a fieldset and an ol tag to wrap inputs</p>
</td></tr><tr><td class='label'>:ol </td><td>
<p>uses an ol tag to wrap inputs, useful with :li wrapper</p>
</td></tr><tr><td class='label'>:table </td><td>
<p>uses a table tag to wrap inputs, useful with :trtd wrapper</p>
</td></tr><tr><td class='label'>:tr </td><td>
<p>uses a tr tag to wrap inputs, useful with :td wrapper</p>
</td></tr></tbody></table>

<p>All of these support the following options:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:attr </td><td>
<p>A hash of attributes to use for the wrapping tag.</p>
</td></tr></tbody></table>

<p>The :default, :fieldset_ol, and :table inputs_wrappers support the following options:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:legend </td><td>
<p>A text description for the inputs, using the legend tag for fieldsets and the caption tag for a table.</p>
</td></tr><tr><td class='label'>:legend_attr </td><td>
<p>A hash of attributes for the legend/caption tag.</p>
</td></tr></tbody></table>

<p>The :table inputs_wrapper also supports the following options:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:labels </td><td>
<p>An array of labels, used to setup a row of table headers with the labels.</p>
</td></tr></tbody></table>

<h2 id="label-Configurations">Configurations<span><a href="#label-Configurations">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>You can associate a group of transformers into a configuration.  This allows you to specify a single :config option when creating a <code>Form</code> and have it automatically set all the related transformers.</p>

<p>There are a few configurations supported by default:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:default </td><td>
<p>All <code>default</code> transformers</p>
</td></tr><tr><td class='label'>:formtastic </td><td>
<p><code>fieldset_ol</code> inputs_wrapper, <code>li</code> wrapper, <code>explicit</code> labeler</p>
</td></tr></tbody></table>

<p>You can register and use your own configurations easily:</p>

<pre class="ruby"><span class="ruby-constant">Forme</span>.<span class="ruby-identifier">register_config</span>(<span class="ruby-value">:mine</span>, <span class="ruby-value">:wrapper</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">:li</span>, <span class="ruby-value">:inputs_wrapper</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">:ol</span>, <span class="ruby-value">:serializer</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">:html_usa</span>)
<span class="ruby-constant">Forme</span><span class="ruby-operator">::</span><span class="ruby-constant">Form</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">:config</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">:mine</span>)
</pre>

<p>If you want to, you can base your configuration on an existing configuration:</p>

<pre class="ruby"><span class="ruby-constant">Forme</span>.<span class="ruby-identifier">register_config</span>(<span class="ruby-value">:yours</span>, <span class="ruby-value">:base</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">:mine</span>, <span class="ruby-value">:inputs_wrapper</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">:fieldset_ol</span>)
</pre>

<p>You can mark a configuration as the default using:</p>

<pre class="ruby"><span class="ruby-constant">Forme</span>.<span class="ruby-identifier">default_config</span> = <span class="ruby-value">:mine</span>
</pre>

<h3 id="label-Bootstrap+Support">Bootstrap Support<span><a href="#label-Bootstrap+Support">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><a href="../classes/Forme.html"><code>Forme</code></a> ships with support for Bootstrap 5 HTML formatting. This support is shipped in itâ€™s own file, so if you donâ€™t use it, you donâ€™t pay the memory penalty for loading it.</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;forme/bs5&#39;</span>
<span class="ruby-constant">Forme</span>.<span class="ruby-identifier">default_config</span> = <span class="ruby-value">:bs5</span>
</pre>

<p>There is also support for Bootstrap versions 3-4:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;forme/bs3&#39;</span>
<span class="ruby-constant">Forme</span>.<span class="ruby-identifier">default_config</span> = <span class="ruby-value">:bs3</span>
</pre>

<h1 id="label-Other+Similar+Projects">Other Similar Projects<span><a href="#label-Other+Similar+Projects">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>All of these have external dependencies:</p>
<ol><li>
<p>Rails built-in helpers</p>
</li><li>
<p>Formtastic</p>
</li><li>
<p>simple_form</p>
</li><li>
<p>padrino-helpers</p>
</li></ol>

<p>Formeâ€™s API draws a lot of inspiration from both Formtastic and simple_form.</p>

<h1 id="label-License">License<span><a href="#label-License">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>MIT</p>

<h1 id="label-Author">Author<span><a href="#label-Author">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>Jeremy Evans &lt;code@jeremyevans.net&gt;</p>
</div>
<div id='context'>
</div>

</div>
</div>

<div id='footer-push'></div>
</div>
<div id='footer'>
<a href="https://github.com/jeremyevans/hanna"><strong>Hanna</strong> RDoc template</a>
</div>
</body>
</html>
